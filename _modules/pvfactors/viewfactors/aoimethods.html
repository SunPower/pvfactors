

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pvfactors.viewfactors.aoimethods &mdash; pvfactors 1.4.1 documentation</title>
  

  
  
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/custom.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> pvfactors
          

          
            
            <img src="../../../_static/logo_small.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                1.4.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation/index.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../concepts/index.html">Main concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../theory/index.html">Theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developer/index.html">Developer API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../whatsnew.html">Whatâ€™s New</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">pvfactors</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>pvfactors.viewfactors.aoimethods</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pvfactors.viewfactors.aoimethods</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Module containing AOI loss calculation methods&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">pvfactors.config</span> <span class="k">import</span> <span class="n">DISTANCE_TOLERANCE</span>
<span class="kn">from</span> <span class="nn">pvfactors.geometry.timeseries</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">TsPointCoords</span><span class="p">,</span> <span class="n">TsSurface</span><span class="p">,</span> <span class="n">TsLineCoords</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">pvfactors</span> <span class="k">import</span> <span class="n">PVFactorsError</span>
<span class="kn">import</span> <span class="nn">pvlib</span>
<span class="kn">from</span> <span class="nn">pvlib.tools</span> <span class="k">import</span> <span class="n">cosd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>


<div class="viewcode-block" id="AOIMethods"><a class="viewcode-back" href="../../../developer/generated/pvfactors.viewfactors.aoimethods.AOIMethods.html#pvfactors.viewfactors.aoimethods.AOIMethods">[docs]</a><span class="k">class</span> <span class="nc">AOIMethods</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Class containing methods related to calculating AOI losses for</span>
<span class="sd">    :py:class:`~pvfactors.geometry.pvarray.OrderedPVArray` objects.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="AOIMethods.__init__"><a class="viewcode-back" href="../../../developer/generated/pvfactors.viewfactors.aoimethods.AOIMethods.html#pvfactors.viewfactors.aoimethods.AOIMethods.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">faoi_fn_front</span><span class="p">,</span> <span class="n">faoi_fn_back</span><span class="p">,</span> <span class="n">n_integral_sections</span><span class="o">=</span><span class="mi">300</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Instantiate class with faoi function and number of sections to use</span>
<span class="sd">        to calculate integrals of view factors with faoi losses</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        faoi_fn_front : function</span>
<span class="sd">            Function which takes a list (or numpy array) of incidence angles</span>
<span class="sd">            measured from the surface horizontal</span>
<span class="sd">            (with values from 0 to 180 deg) and returns the fAOI values for</span>
<span class="sd">            the front side of PV rows</span>
<span class="sd">        faoi_fn_back : function</span>
<span class="sd">            Function which takes a list (or numpy array) of incidence angles</span>
<span class="sd">            measured from the surface horizontal</span>
<span class="sd">            (with values from 0 to 180 deg) and returns the fAOI values for</span>
<span class="sd">            the back side of PV rows</span>
<span class="sd">        n_integral_sections : int, optional</span>
<span class="sd">            Number of integral divisions of the 0 to 180 deg interval</span>
<span class="sd">            to use for the fAOI loss integral (default = 300)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check that faoi fn where passed</span>
        <span class="n">faoi_fns_ok</span> <span class="o">=</span> <span class="n">callable</span><span class="p">(</span><span class="n">faoi_fn_front</span><span class="p">)</span> <span class="ow">and</span> <span class="n">callable</span><span class="p">(</span><span class="n">faoi_fn_back</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">faoi_fns_ok</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">PVFactorsError</span><span class="p">(</span><span class="s2">&quot;The faoi_fn passed to the AOI methods are &quot;</span>
                                 <span class="s2">&quot;not callable. Please check the fAOI &quot;</span>
                                 <span class="s2">&quot;functions again&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">faoi_fn_front</span> <span class="o">=</span> <span class="n">faoi_fn_front</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">faoi_fn_back</span> <span class="o">=</span> <span class="n">faoi_fn_back</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_integral_sections</span> <span class="o">=</span> <span class="n">n_integral_sections</span>
        <span class="c1"># The following will be updated at fitting time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interval</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aoi_angles_low</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aoi_angles_high</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">integrand_front</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">integrand_back</span> <span class="o">=</span> <span class="kc">None</span></div>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_timestamps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fit the AOI methods to timeseries inputs: create all the necessary</span>
<span class="sd">        integration attributes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_timestamps : int</span>
<span class="sd">            Number of simulation timestamps</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Will use x values at the middle of the integral sections</span>
        <span class="n">aoi_angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">180.</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_integral_sections</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Assumes that at least 2 aoi angle values, otherwise what&#39;s the point</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interval</span> <span class="o">=</span> <span class="n">aoi_angles</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">aoi_angles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Get integral intervals&#39; low, high, and middle points</span>
        <span class="n">aoi_angles_low</span> <span class="o">=</span> <span class="n">aoi_angles</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">aoi_angles_high</span> <span class="o">=</span> <span class="n">aoi_angles_low</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">interval</span>
        <span class="n">aoi_angles_middle</span> <span class="o">=</span> <span class="n">aoi_angles_low</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">interval</span> <span class="o">/</span> <span class="mf">2.</span>
        <span class="c1"># Calculate faoi values using middle points of integral intervals</span>
        <span class="n">faoi_front</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">faoi_fn_front</span><span class="p">(</span><span class="n">aoi_angles_middle</span><span class="p">)</span>
        <span class="n">faoi_back</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">faoi_fn_back</span><span class="p">(</span><span class="n">aoi_angles_middle</span><span class="p">)</span>
        <span class="c1"># Calculate small view factor values for each section</span>
        <span class="n">vf_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vf</span><span class="p">(</span><span class="n">aoi_angles_low</span><span class="p">,</span> <span class="n">aoi_angles_high</span><span class="p">)</span>
        <span class="c1"># Multiply to get integrand</span>
        <span class="n">integrand_front</span> <span class="o">=</span> <span class="n">faoi_front</span> <span class="o">*</span> <span class="n">vf_values</span>
        <span class="n">integrand_back</span> <span class="o">=</span> <span class="n">faoi_back</span> <span class="o">*</span> <span class="n">vf_values</span>
        <span class="c1"># Replicate these values for all timestamps such that shapes</span>
        <span class="c1"># becomes: [n_timestamps, n_integral_sections]map</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aoi_angles_low</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">aoi_angles_low</span><span class="p">,</span> <span class="p">(</span><span class="n">n_timestamps</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aoi_angles_high</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">aoi_angles_high</span><span class="p">,</span> <span class="p">(</span><span class="n">n_timestamps</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">integrand_front</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">integrand_front</span><span class="p">,</span> <span class="p">(</span><span class="n">n_timestamps</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">integrand_back</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">integrand_back</span><span class="p">,</span> <span class="p">(</span><span class="n">n_timestamps</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">vf_aoi_pvrow_to_sky</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ts_pvrows</span><span class="p">,</span> <span class="n">ts_ground</span><span class="p">,</span> <span class="n">tilted_to_left</span><span class="p">,</span>
                            <span class="n">vf_matrix</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the view factors between timeseries PV row surface and sky</span>
<span class="sd">        while accounting for AOI losses,</span>
<span class="sd">        and assign values to the passed view factor matrix using</span>
<span class="sd">        the surface indices.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ts_pvrows : list of :py:class:`~pvfactors.geometry.timeseries.TsPVRow`</span>
<span class="sd">            List of timeseries PV rows in the PV array</span>
<span class="sd">        ts_ground : :py:class:`~pvfactors.geometry.timeseries.TsGround`</span>
<span class="sd">            Timeseries ground of the PV array</span>
<span class="sd">        tilted_to_left : list of bool</span>
<span class="sd">            Flags indicating when the PV rows are strictly tilted to the left</span>
<span class="sd">        vf_matrix : np.ndarray</span>
<span class="sd">            View factor matrix to update during calculation. Should have 3</span>
<span class="sd">            dimensions as follows: [n_surfaces, n_surfaces, n_timesteps]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sky_index</span> <span class="o">=</span> <span class="n">vf_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="c1"># --- Build list of dummy sky surfaces</span>
        <span class="c1"># create sky left open area</span>
        <span class="n">pt_1</span> <span class="o">=</span> <span class="n">TsPointCoords</span><span class="p">(</span><span class="n">ts_ground</span><span class="o">.</span><span class="n">x_min</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">tilted_to_left</span><span class="p">),</span>
                             <span class="n">ts_ground</span><span class="o">.</span><span class="n">y_ground</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">tilted_to_left</span><span class="p">))</span>
        <span class="n">pt_2</span> <span class="o">=</span> <span class="n">ts_pvrows</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">highest_point</span>
        <span class="n">sky_left</span> <span class="o">=</span> <span class="n">TsSurface</span><span class="p">(</span><span class="n">TsLineCoords</span><span class="p">(</span><span class="n">pt_1</span><span class="p">,</span> <span class="n">pt_2</span><span class="p">))</span>
        <span class="c1"># create sky right open area</span>
        <span class="n">pt_1</span> <span class="o">=</span> <span class="n">TsPointCoords</span><span class="p">(</span><span class="n">ts_ground</span><span class="o">.</span><span class="n">x_max</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">tilted_to_left</span><span class="p">),</span>
                             <span class="n">ts_ground</span><span class="o">.</span><span class="n">y_ground</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">tilted_to_left</span><span class="p">))</span>
        <span class="n">pt_2</span> <span class="o">=</span> <span class="n">ts_pvrows</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">highest_point</span>
        <span class="n">sky_right</span> <span class="o">=</span> <span class="n">TsSurface</span><span class="p">(</span><span class="n">TsLineCoords</span><span class="p">(</span><span class="n">pt_2</span><span class="p">,</span> <span class="n">pt_1</span><span class="p">))</span>
        <span class="c1"># Add sky surfaces in-between PV rows</span>
        <span class="n">dummy_sky_surfaces</span> <span class="o">=</span> <span class="p">[</span><span class="n">sky_left</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">idx_pvrow</span><span class="p">,</span> <span class="n">ts_pvrow</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ts_pvrows</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">right_ts_pvrow</span> <span class="o">=</span> <span class="n">ts_pvrows</span><span class="p">[</span><span class="n">idx_pvrow</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">pt_1</span> <span class="o">=</span> <span class="n">ts_pvrow</span><span class="o">.</span><span class="n">highest_point</span>
            <span class="n">pt_2</span> <span class="o">=</span> <span class="n">right_ts_pvrow</span><span class="o">.</span><span class="n">highest_point</span>
            <span class="n">sky_surface</span> <span class="o">=</span> <span class="n">TsSurface</span><span class="p">(</span><span class="n">TsLineCoords</span><span class="p">(</span><span class="n">pt_1</span><span class="p">,</span> <span class="n">pt_2</span><span class="p">))</span>
            <span class="n">dummy_sky_surfaces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sky_surface</span><span class="p">)</span>
        <span class="c1"># Add sky right open area</span>
        <span class="n">dummy_sky_surfaces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sky_right</span><span class="p">)</span>

        <span class="c1"># Now calculate vf_aoi for all PV row surfaces to sky</span>
        <span class="k">for</span> <span class="n">idx_pvrow</span><span class="p">,</span> <span class="n">ts_pvrow</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ts_pvrows</span><span class="p">):</span>
            <span class="c1"># Get dummy sky surfaces</span>
            <span class="n">sky_left</span> <span class="o">=</span> <span class="n">dummy_sky_surfaces</span><span class="p">[</span><span class="n">idx_pvrow</span><span class="p">]</span>
            <span class="n">sky_right</span> <span class="o">=</span> <span class="n">dummy_sky_surfaces</span><span class="p">[</span><span class="n">idx_pvrow</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="c1"># Calculate vf_aoi for surfaces in PV row</span>
            <span class="c1"># front side</span>
            <span class="n">front</span> <span class="o">=</span> <span class="n">ts_pvrow</span><span class="o">.</span><span class="n">front</span>
            <span class="k">for</span> <span class="n">front_surf</span> <span class="ow">in</span> <span class="n">front</span><span class="o">.</span><span class="n">all_ts_surfaces</span><span class="p">:</span>
                <span class="n">vf_aoi_left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vf_aoi_surface_to_surface</span><span class="p">(</span>
                    <span class="n">front_surf</span><span class="p">,</span> <span class="n">sky_left</span><span class="p">,</span> <span class="n">is_back</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">vf_aoi_right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vf_aoi_surface_to_surface</span><span class="p">(</span>
                    <span class="n">front_surf</span><span class="p">,</span> <span class="n">sky_right</span><span class="p">,</span> <span class="n">is_back</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">vf_aoi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">tilted_to_left</span><span class="p">,</span> <span class="n">vf_aoi_left</span><span class="p">,</span> <span class="n">vf_aoi_right</span><span class="p">)</span>
                <span class="n">vf_matrix</span><span class="p">[</span><span class="n">front_surf</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">sky_index</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">vf_aoi</span>
            <span class="c1"># back side</span>
            <span class="n">back</span> <span class="o">=</span> <span class="n">ts_pvrow</span><span class="o">.</span><span class="n">back</span>
            <span class="k">for</span> <span class="n">back_surf</span> <span class="ow">in</span> <span class="n">back</span><span class="o">.</span><span class="n">all_ts_surfaces</span><span class="p">:</span>
                <span class="n">vf_aoi_left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vf_aoi_surface_to_surface</span><span class="p">(</span>
                    <span class="n">back_surf</span><span class="p">,</span> <span class="n">sky_left</span><span class="p">,</span> <span class="n">is_back</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">vf_aoi_right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vf_aoi_surface_to_surface</span><span class="p">(</span>
                    <span class="n">back_surf</span><span class="p">,</span> <span class="n">sky_right</span><span class="p">,</span> <span class="n">is_back</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">vf_aoi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">tilted_to_left</span><span class="p">,</span> <span class="n">vf_aoi_right</span><span class="p">,</span> <span class="n">vf_aoi_left</span><span class="p">)</span>
                <span class="n">vf_matrix</span><span class="p">[</span><span class="n">back_surf</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">sky_index</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">vf_aoi</span>

    <span class="k">def</span> <span class="nf">vf_aoi_pvrow_to_pvrow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ts_pvrows</span><span class="p">,</span> <span class="n">tilted_to_left</span><span class="p">,</span> <span class="n">vf_matrix</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the view factors between timeseries PV row surfaces</span>
<span class="sd">        while accounting for AOI losses,</span>
<span class="sd">        and assign values to the passed view factor matrix using</span>
<span class="sd">        the surface indices.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ts_pvrows : list of :py:class:`~pvfactors.geometry.timeseries.TsPVRow`</span>
<span class="sd">            List of timeseries PV rows in the PV array</span>
<span class="sd">        tilted_to_left : list of bool</span>
<span class="sd">            Flags indicating when the PV rows are strictly tilted to the left</span>
<span class="sd">        vf_matrix : np.ndarray</span>
<span class="sd">            View factor matrix to update during calculation. Should have 3</span>
<span class="sd">            dimensions as follows: [n_surfaces, n_surfaces, n_timesteps]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">idx_pvrow</span><span class="p">,</span> <span class="n">ts_pvrow</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ts_pvrows</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="c1"># Get the next pv row</span>
            <span class="n">right_ts_pvrow</span> <span class="o">=</span> <span class="n">ts_pvrows</span><span class="p">[</span><span class="n">idx_pvrow</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="c1"># front side</span>
            <span class="n">front</span> <span class="o">=</span> <span class="n">ts_pvrow</span><span class="o">.</span><span class="n">front</span>
            <span class="k">for</span> <span class="n">surf_i</span> <span class="ow">in</span> <span class="n">front</span><span class="o">.</span><span class="n">all_ts_surfaces</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">surf_i</span><span class="o">.</span><span class="n">index</span>
                <span class="k">for</span> <span class="n">surf_j</span> <span class="ow">in</span> <span class="n">right_ts_pvrow</span><span class="o">.</span><span class="n">back</span><span class="o">.</span><span class="n">all_ts_surfaces</span><span class="p">:</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="n">surf_j</span><span class="o">.</span><span class="n">index</span>
                    <span class="c1"># vf aoi from i to j</span>
                    <span class="n">vf_i_to_j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vf_aoi_surface_to_surface</span><span class="p">(</span>
                        <span class="n">surf_i</span><span class="p">,</span> <span class="n">surf_j</span><span class="p">,</span> <span class="n">is_back</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">vf_i_to_j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">tilted_to_left</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">vf_i_to_j</span><span class="p">)</span>
                    <span class="c1"># vf aoi from j to i</span>
                    <span class="n">vf_j_to_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vf_aoi_surface_to_surface</span><span class="p">(</span>
                        <span class="n">surf_j</span><span class="p">,</span> <span class="n">surf_i</span><span class="p">,</span> <span class="n">is_back</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">vf_j_to_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">tilted_to_left</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">vf_j_to_i</span><span class="p">)</span>
                    <span class="c1"># save results</span>
                    <span class="n">vf_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">vf_i_to_j</span>
                    <span class="n">vf_matrix</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">vf_j_to_i</span>
            <span class="c1"># back side</span>
            <span class="n">back</span> <span class="o">=</span> <span class="n">ts_pvrow</span><span class="o">.</span><span class="n">back</span>
            <span class="k">for</span> <span class="n">surf_i</span> <span class="ow">in</span> <span class="n">back</span><span class="o">.</span><span class="n">all_ts_surfaces</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">surf_i</span><span class="o">.</span><span class="n">index</span>
                <span class="k">for</span> <span class="n">surf_j</span> <span class="ow">in</span> <span class="n">right_ts_pvrow</span><span class="o">.</span><span class="n">front</span><span class="o">.</span><span class="n">all_ts_surfaces</span><span class="p">:</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="n">surf_j</span><span class="o">.</span><span class="n">index</span>
                    <span class="c1"># vf aoi from i to j</span>
                    <span class="n">vf_i_to_j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vf_aoi_surface_to_surface</span><span class="p">(</span>
                        <span class="n">surf_i</span><span class="p">,</span> <span class="n">surf_j</span><span class="p">,</span> <span class="n">is_back</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">vf_i_to_j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">tilted_to_left</span><span class="p">,</span> <span class="n">vf_i_to_j</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span>
                    <span class="c1"># vf aoi from j to i</span>
                    <span class="n">vf_j_to_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vf_aoi_surface_to_surface</span><span class="p">(</span>
                        <span class="n">surf_j</span><span class="p">,</span> <span class="n">surf_i</span><span class="p">,</span> <span class="n">is_back</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">vf_j_to_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">tilted_to_left</span><span class="p">,</span> <span class="n">vf_j_to_i</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span>
                    <span class="c1"># save results</span>
                    <span class="n">vf_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">vf_i_to_j</span>
                    <span class="n">vf_matrix</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">vf_j_to_i</span>

    <span class="k">def</span> <span class="nf">vf_aoi_pvrow_to_gnd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ts_pvrows</span><span class="p">,</span> <span class="n">ts_ground</span><span class="p">,</span> <span class="n">tilted_to_left</span><span class="p">,</span>
                            <span class="n">vf_aoi_matrix</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the view factors between timeseries PV row and ground</span>
<span class="sd">        surfaces while accounting for non-diffuse AOI losses,</span>
<span class="sd">        and assign it to the passed view factor aoi matrix using</span>
<span class="sd">        the surface indices.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This assumes that the PV row surfaces are infinitesimal (very small)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ts_pvrows : list of :py:class:`~pvfactors.geometry.timeseries.TsPVRow`</span>
<span class="sd">            List of timeseries PV rows in the PV array</span>
<span class="sd">        ts_ground : :py:class:`~pvfactors.geometry.timeseries.TsGround`</span>
<span class="sd">            Timeseries ground of the PV array</span>
<span class="sd">        tilted_to_left : list of bool</span>
<span class="sd">            Flags indicating when the PV rows are strictly tilted to the left</span>
<span class="sd">        vf_aoi_matrix : np.ndarray</span>
<span class="sd">            View factor aoi matrix to update during calculation. Should have 3</span>
<span class="sd">            dimensions as follows: [n_surfaces, n_surfaces, n_timesteps]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_pvrows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ts_pvrows</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idx_pvrow</span><span class="p">,</span> <span class="n">ts_pvrow</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ts_pvrows</span><span class="p">):</span>
            <span class="c1"># Separate gnd surfaces depending on side</span>
            <span class="n">left_gnd_surfaces</span> <span class="o">=</span> <span class="n">ts_ground</span><span class="o">.</span><span class="n">ts_surfaces_side_of_cut_point</span><span class="p">(</span>
                <span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">idx_pvrow</span><span class="p">)</span>
            <span class="n">right_gnd_surfaces</span> <span class="o">=</span> <span class="n">ts_ground</span><span class="o">.</span><span class="n">ts_surfaces_side_of_cut_point</span><span class="p">(</span>
                <span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="n">idx_pvrow</span><span class="p">)</span>
            <span class="c1"># Front side</span>
            <span class="n">front</span> <span class="o">=</span> <span class="n">ts_pvrow</span><span class="o">.</span><span class="n">front</span>
            <span class="k">for</span> <span class="n">pvrow_surf</span> <span class="ow">in</span> <span class="n">front</span><span class="o">.</span><span class="n">all_ts_surfaces</span><span class="p">:</span>
                <span class="n">ts_length</span> <span class="o">=</span> <span class="n">pvrow_surf</span><span class="o">.</span><span class="n">length</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">pvrow_surf</span><span class="o">.</span><span class="n">index</span>
                <span class="k">for</span> <span class="n">gnd_surf</span> <span class="ow">in</span> <span class="n">left_gnd_surfaces</span><span class="p">:</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="n">gnd_surf</span><span class="o">.</span><span class="n">index</span>
                    <span class="n">vf_pvrow_to_gnd</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_vf_aoi_pvrow_surf_to_gnd_surf_obstruction</span><span class="p">(</span>
                            <span class="n">pvrow_surf</span><span class="p">,</span> <span class="n">idx_pvrow</span><span class="p">,</span> <span class="n">n_pvrows</span><span class="p">,</span>
                            <span class="n">tilted_to_left</span><span class="p">,</span> <span class="n">ts_pvrows</span><span class="p">,</span> <span class="n">gnd_surf</span><span class="p">,</span> <span class="n">ts_length</span><span class="p">,</span>
                            <span class="n">is_back</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">is_left</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
                    <span class="n">vf_aoi_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">vf_pvrow_to_gnd</span>
                <span class="k">for</span> <span class="n">gnd_surf</span> <span class="ow">in</span> <span class="n">right_gnd_surfaces</span><span class="p">:</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="n">gnd_surf</span><span class="o">.</span><span class="n">index</span>
                    <span class="n">vf_pvrow_to_gnd</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_vf_aoi_pvrow_surf_to_gnd_surf_obstruction</span><span class="p">(</span>
                            <span class="n">pvrow_surf</span><span class="p">,</span> <span class="n">idx_pvrow</span><span class="p">,</span> <span class="n">n_pvrows</span><span class="p">,</span>
                            <span class="n">tilted_to_left</span><span class="p">,</span> <span class="n">ts_pvrows</span><span class="p">,</span> <span class="n">gnd_surf</span><span class="p">,</span> <span class="n">ts_length</span><span class="p">,</span>
                            <span class="n">is_back</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">is_left</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
                    <span class="n">vf_aoi_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">vf_pvrow_to_gnd</span>
            <span class="c1"># Back side</span>
            <span class="n">back</span> <span class="o">=</span> <span class="n">ts_pvrow</span><span class="o">.</span><span class="n">back</span>
            <span class="k">for</span> <span class="n">pvrow_surf</span> <span class="ow">in</span> <span class="n">back</span><span class="o">.</span><span class="n">all_ts_surfaces</span><span class="p">:</span>
                <span class="n">ts_length</span> <span class="o">=</span> <span class="n">pvrow_surf</span><span class="o">.</span><span class="n">length</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">pvrow_surf</span><span class="o">.</span><span class="n">index</span>
                <span class="k">for</span> <span class="n">gnd_surf</span> <span class="ow">in</span> <span class="n">left_gnd_surfaces</span><span class="p">:</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="n">gnd_surf</span><span class="o">.</span><span class="n">index</span>
                    <span class="n">vf_pvrow_to_gnd</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_vf_aoi_pvrow_surf_to_gnd_surf_obstruction</span><span class="p">(</span>
                            <span class="n">pvrow_surf</span><span class="p">,</span> <span class="n">idx_pvrow</span><span class="p">,</span> <span class="n">n_pvrows</span><span class="p">,</span>
                            <span class="n">tilted_to_left</span><span class="p">,</span> <span class="n">ts_pvrows</span><span class="p">,</span> <span class="n">gnd_surf</span><span class="p">,</span> <span class="n">ts_length</span><span class="p">,</span>
                            <span class="n">is_back</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">is_left</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
                    <span class="n">vf_aoi_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">vf_pvrow_to_gnd</span>
                <span class="k">for</span> <span class="n">gnd_surf</span> <span class="ow">in</span> <span class="n">right_gnd_surfaces</span><span class="p">:</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="n">gnd_surf</span><span class="o">.</span><span class="n">index</span>
                    <span class="n">vf_pvrow_to_gnd</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_vf_aoi_pvrow_surf_to_gnd_surf_obstruction</span><span class="p">(</span>
                            <span class="n">pvrow_surf</span><span class="p">,</span> <span class="n">idx_pvrow</span><span class="p">,</span> <span class="n">n_pvrows</span><span class="p">,</span>
                            <span class="n">tilted_to_left</span><span class="p">,</span> <span class="n">ts_pvrows</span><span class="p">,</span> <span class="n">gnd_surf</span><span class="p">,</span> <span class="n">ts_length</span><span class="p">,</span>
                            <span class="n">is_back</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">is_left</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
                    <span class="n">vf_aoi_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">vf_pvrow_to_gnd</span>

    <span class="k">def</span> <span class="nf">_vf_aoi_surface_to_surface</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">surf_1</span><span class="p">,</span> <span class="n">surf_2</span><span class="p">,</span> <span class="n">is_back</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate view factor, while accounting from AOI losses, from</span>
<span class="sd">        surface 1 to surface 2.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This assumes that surf_1 is infinitesimal (very small)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        surf_1 : :py:class:`~pvfactors.geometry.timeseries.TsSurface`</span>
<span class="sd">            Infinitesimal surface from which to calculate view factor with</span>
<span class="sd">            AOI losses</span>
<span class="sd">        surf_2 : :py:class:`~pvfactors.geometry.timeseries.TsSurface`</span>
<span class="sd">            Surface to which the view factor with AOI losses should be</span>
<span class="sd">            calculated</span>
<span class="sd">        is_back : bool</span>
<span class="sd">            Flag specifying whether pv row surface is on back or front side</span>
<span class="sd">            of PV row (Default = True)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        vf_aoi : np.ndarray</span>
<span class="sd">            View factors with aoi losses from surface 1 to surface 2,</span>
<span class="sd">            dimension is [n_timesteps]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># skip calculation if either surface is empty (always zero length)</span>
        <span class="n">skip</span> <span class="o">=</span> <span class="n">surf_1</span><span class="o">.</span><span class="n">is_empty</span> <span class="ow">or</span> <span class="n">surf_2</span><span class="o">.</span><span class="n">is_empty</span>
        <span class="k">if</span> <span class="n">skip</span><span class="p">:</span>
            <span class="n">vf_aoi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">surf_2</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Get surface 1 params</span>
            <span class="n">u_vector</span> <span class="o">=</span> <span class="n">surf_1</span><span class="o">.</span><span class="n">u_vector</span>
            <span class="n">centroid</span> <span class="o">=</span> <span class="n">surf_1</span><span class="o">.</span><span class="n">centroid</span>
            <span class="c1"># Calculate AOI angles</span>
            <span class="n">aoi_angles_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_aoi_angles</span><span class="p">(</span><span class="n">u_vector</span><span class="p">,</span> <span class="n">centroid</span><span class="p">,</span>
                                                      <span class="n">surf_2</span><span class="o">.</span><span class="n">b1</span><span class="p">)</span>
            <span class="n">aoi_angles_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_aoi_angles</span><span class="p">(</span><span class="n">u_vector</span><span class="p">,</span> <span class="n">centroid</span><span class="p">,</span>
                                                      <span class="n">surf_2</span><span class="o">.</span><span class="n">b2</span><span class="p">)</span>
            <span class="n">low_aoi_angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">aoi_angles_1</span> <span class="o">&lt;</span> <span class="n">aoi_angles_2</span><span class="p">,</span> <span class="n">aoi_angles_1</span><span class="p">,</span>
                                      <span class="n">aoi_angles_2</span><span class="p">)</span>
            <span class="n">high_aoi_angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">aoi_angles_1</span> <span class="o">&lt;</span> <span class="n">aoi_angles_2</span><span class="p">,</span> <span class="n">aoi_angles_2</span><span class="p">,</span>
                                       <span class="n">aoi_angles_1</span><span class="p">)</span>
            <span class="c1"># Calculate vf_aoi</span>
            <span class="n">vf_aoi_raw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_vf_aoi_wedge_level</span><span class="p">(</span>
                <span class="n">low_aoi_angles</span><span class="p">,</span> <span class="n">high_aoi_angles</span><span class="p">,</span> <span class="n">is_back</span><span class="o">=</span><span class="n">is_back</span><span class="p">)</span>
            <span class="c1"># Should be zero where either of the surfaces have zero length</span>
            <span class="n">vf_aoi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">surf_1</span><span class="o">.</span><span class="n">length</span> <span class="o">&lt;</span> <span class="n">DISTANCE_TOLERANCE</span><span class="p">)</span>
                              <span class="o">|</span> <span class="p">(</span><span class="n">surf_2</span><span class="o">.</span><span class="n">length</span> <span class="o">&lt;</span> <span class="n">DISTANCE_TOLERANCE</span><span class="p">),</span> <span class="mf">0.</span><span class="p">,</span>
                              <span class="n">vf_aoi_raw</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">vf_aoi</span>

    <span class="k">def</span> <span class="nf">_vf_aoi_pvrow_surf_to_gnd_surf_obstruction</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">pvrow_surf</span><span class="p">,</span> <span class="n">pvrow_idx</span><span class="p">,</span> <span class="n">n_pvrows</span><span class="p">,</span> <span class="n">tilted_to_left</span><span class="p">,</span> <span class="n">ts_pvrows</span><span class="p">,</span>
            <span class="n">gnd_surf</span><span class="p">,</span> <span class="n">ts_length</span><span class="p">,</span> <span class="n">is_back</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">is_left</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate view factors from timeseries PV row surface to a</span>
<span class="sd">        timeseries ground surface, accounting for AOI losses.</span>
<span class="sd">        This will return the calculated view</span>
<span class="sd">        factors from the PV row surface to the ground surface.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This assumes that the PV row surfaces are infinitesimal (very small)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pvrow_surf : :py:class:`~pvfactors.geometry.timeseries.TsSurface`</span>
<span class="sd">            Timeseries PV row surface to use for calculation</span>
<span class="sd">        pvrow_idx : int</span>
<span class="sd">            Index of the timeseries PV row on the which the pvrow_surf is</span>
<span class="sd">        n_pvrows : int</span>
<span class="sd">            Number of timeseries PV rows in the PV array, and therefore number</span>
<span class="sd">            of shadows they cast on the ground</span>
<span class="sd">        tilted_to_left : list of bool</span>
<span class="sd">            Flags indicating when the PV rows are strictly tilted to the left</span>
<span class="sd">        ts_pvrows : list of :py:class:`~pvfactors.geometry.timeseries.TsPVRow`</span>
<span class="sd">            List of timeseries PV rows in the PV array</span>
<span class="sd">        gnd_surf : :py:class:`~pvfactors.geometry.timeseries.TsSurface`</span>
<span class="sd">            Timeseries ground surface to use for calculation</span>
<span class="sd">        pvrow_surf_length : np.ndarray</span>
<span class="sd">            Length (width) of the timeseries PV row surface [m]</span>
<span class="sd">        is_back : bool</span>
<span class="sd">            Flag specifying whether pv row surface is on back or front side</span>
<span class="sd">            of PV row (Default = True)</span>
<span class="sd">        is_left : bool</span>
<span class="sd">            Flag specifying whether gnd surface is left of pv row cut point or</span>
<span class="sd">            not (Default = True)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        vf_aoi_pvrow_to_gnd_surf : np.ndarray</span>
<span class="sd">            View factors aoi from timeseries PV row surface to timeseries</span>
<span class="sd">            ground surface, dimension is [n_timesteps]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># skip calculation if either surface is empty (always zero length)</span>
        <span class="n">skip</span> <span class="o">=</span> <span class="n">pvrow_surf</span><span class="o">.</span><span class="n">is_empty</span> <span class="ow">or</span> <span class="n">gnd_surf</span><span class="o">.</span><span class="n">is_empty</span>
        <span class="k">if</span> <span class="n">skip</span><span class="p">:</span>
            <span class="n">vf_aoi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">gnd_surf</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">centroid</span> <span class="o">=</span> <span class="n">pvrow_surf</span><span class="o">.</span><span class="n">centroid</span>
            <span class="n">u_vector</span> <span class="o">=</span> <span class="n">pvrow_surf</span><span class="o">.</span><span class="n">u_vector</span>
            <span class="n">no_obstruction</span> <span class="o">=</span> <span class="p">(</span><span class="n">is_left</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">pvrow_idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> \
                <span class="ow">or</span> <span class="p">((</span><span class="ow">not</span> <span class="n">is_left</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">pvrow_idx</span> <span class="o">==</span> <span class="n">n_pvrows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">no_obstruction</span><span class="p">:</span>
                <span class="c1"># There is no obstruction to the ground surface</span>
                <span class="n">aoi_angles_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_aoi_angles</span><span class="p">(</span><span class="n">u_vector</span><span class="p">,</span> <span class="n">centroid</span><span class="p">,</span>
                                                          <span class="n">gnd_surf</span><span class="o">.</span><span class="n">b1</span><span class="p">)</span>
                <span class="n">aoi_angles_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_aoi_angles</span><span class="p">(</span><span class="n">u_vector</span><span class="p">,</span> <span class="n">centroid</span><span class="p">,</span>
                                                          <span class="n">gnd_surf</span><span class="o">.</span><span class="n">b2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Get lowest point of obstructing point</span>
                <span class="n">idx_obstructing_pvrow</span> <span class="o">=</span> <span class="p">(</span><span class="n">pvrow_idx</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">is_left</span>
                                         <span class="k">else</span> <span class="n">pvrow_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">pt_obstr</span> <span class="o">=</span> <span class="n">ts_pvrows</span><span class="p">[</span><span class="n">idx_obstructing_pvrow</span>
                                     <span class="p">]</span><span class="o">.</span><span class="n">full_pvrow_coords</span><span class="o">.</span><span class="n">lowest_point</span>
                <span class="c1"># Adjust angle seen when there is obstruction</span>
                <span class="n">aoi_angles_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_aoi_angles_w_obstruction</span><span class="p">(</span>
                    <span class="n">u_vector</span><span class="p">,</span> <span class="n">centroid</span><span class="p">,</span> <span class="n">gnd_surf</span><span class="o">.</span><span class="n">b1</span><span class="p">,</span> <span class="n">pt_obstr</span><span class="p">,</span> <span class="n">is_left</span><span class="p">)</span>
                <span class="n">aoi_angles_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_aoi_angles_w_obstruction</span><span class="p">(</span>
                    <span class="n">u_vector</span><span class="p">,</span> <span class="n">centroid</span><span class="p">,</span> <span class="n">gnd_surf</span><span class="o">.</span><span class="n">b2</span><span class="p">,</span> <span class="n">pt_obstr</span><span class="p">,</span> <span class="n">is_left</span><span class="p">)</span>

            <span class="n">low_aoi_angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">aoi_angles_1</span> <span class="o">&lt;</span> <span class="n">aoi_angles_2</span><span class="p">,</span>
                                      <span class="n">aoi_angles_1</span><span class="p">,</span> <span class="n">aoi_angles_2</span><span class="p">)</span>
            <span class="n">high_aoi_angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">aoi_angles_1</span> <span class="o">&lt;</span> <span class="n">aoi_angles_2</span><span class="p">,</span>
                                       <span class="n">aoi_angles_2</span><span class="p">,</span> <span class="n">aoi_angles_1</span><span class="p">)</span>
            <span class="n">vf_aoi_raw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_vf_aoi_wedge_level</span><span class="p">(</span>
                <span class="n">low_aoi_angles</span><span class="p">,</span> <span class="n">high_aoi_angles</span><span class="p">,</span> <span class="n">is_back</span><span class="o">=</span><span class="n">is_back</span><span class="p">)</span>
            <span class="c1"># Should be zero where either of the surfaces have zero length</span>
            <span class="n">vf_aoi_raw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">ts_length</span> <span class="o">&lt;</span> <span class="n">DISTANCE_TOLERANCE</span><span class="p">)</span>
                                  <span class="o">|</span> <span class="p">(</span><span class="n">gnd_surf</span><span class="o">.</span><span class="n">length</span> <span class="o">&lt;</span> <span class="n">DISTANCE_TOLERANCE</span><span class="p">),</span> <span class="mf">0.</span><span class="p">,</span>
                                  <span class="n">vf_aoi_raw</span><span class="p">)</span>

            <span class="c1"># Final result depends on whether front or back surface</span>
            <span class="k">if</span> <span class="n">is_left</span><span class="p">:</span>
                <span class="n">vf_aoi</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">tilted_to_left</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">vf_aoi_raw</span><span class="p">)</span> <span class="k">if</span> <span class="n">is_back</span>
                          <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">tilted_to_left</span><span class="p">,</span> <span class="n">vf_aoi_raw</span><span class="p">,</span> <span class="mf">0.</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">vf_aoi</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">tilted_to_left</span><span class="p">,</span> <span class="n">vf_aoi_raw</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span> <span class="k">if</span> <span class="n">is_back</span>
                          <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">tilted_to_left</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">vf_aoi_raw</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">vf_aoi</span>

    <span class="k">def</span> <span class="nf">_calculate_aoi_angles_w_obstruction</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">u_vector</span><span class="p">,</span> <span class="n">centroid</span><span class="p">,</span> <span class="n">point_gnd</span><span class="p">,</span> <span class="n">point_obstr</span><span class="p">,</span>
            <span class="n">gnd_surf_is_left</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate AOI angles for a PV row surface of the</span>
<span class="sd">        :py:class:`~pvfactors.geometry.pvarray.OrderedPVArray` that sees</span>
<span class="sd">        a ground surface, while being potentially obstructed by another</span>
<span class="sd">        PV row</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        u_vector : np.ndarray</span>
<span class="sd">            Direction vector of the surface for which to calculate AOI angles</span>
<span class="sd">        centroid : :py:class:`~pvfactors.geometry.timeseries.TsPointCoords`</span>
<span class="sd">            Centroid point of PV row surface for which to calculate AOI angles</span>
<span class="sd">        point : :py:class:`~pvfactors.geometry.timeseries.TsPointCoords`</span>
<span class="sd">            Point of ground surface that will determine AOI angle</span>
<span class="sd">        point_obstr: :py:class:`~pvfactors.geometry.timeseries.TsPointCoords`</span>
<span class="sd">            Potentially obstructing point for the view aoi angle calculation</span>
<span class="sd">        gnd_surf_is_left : bool</span>
<span class="sd">            Flag specifying whether ground surface is left of PV row&#39;s cut</span>
<span class="sd">            point or not</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            AOI angles formed by remote point and centroid on surface,</span>
<span class="sd">            measured against surface direction vector, accounting for</span>
<span class="sd">            potential obstruction [degrees]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">point_obstr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># There is no obstruction</span>
            <span class="n">point</span> <span class="o">=</span> <span class="n">point_gnd</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Determine if there is obstruction by using the angles made by</span>
            <span class="c1"># specific strings with the x-axis</span>
            <span class="n">alpha_pv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_angle_with_x_axis</span><span class="p">(</span><span class="n">point_gnd</span><span class="p">,</span> <span class="n">centroid</span><span class="p">)</span>
            <span class="n">alpha_ob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_angle_with_x_axis</span><span class="p">(</span><span class="n">point_gnd</span><span class="p">,</span> <span class="n">point_obstr</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">gnd_surf_is_left</span><span class="p">:</span>
                <span class="n">is_obstructing</span> <span class="o">=</span> <span class="n">alpha_pv</span> <span class="o">&gt;</span> <span class="n">alpha_ob</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">is_obstructing</span> <span class="o">=</span> <span class="n">alpha_pv</span> <span class="o">&lt;</span> <span class="n">alpha_ob</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">is_obstructing</span><span class="p">,</span> <span class="n">point_obstr</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">point_gnd</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">is_obstructing</span><span class="p">,</span> <span class="n">point_obstr</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">point_gnd</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
            <span class="n">point</span> <span class="o">=</span> <span class="n">TsPointCoords</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

        <span class="n">aoi_angles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_aoi_angles</span><span class="p">(</span><span class="n">u_vector</span><span class="p">,</span> <span class="n">centroid</span><span class="p">,</span> <span class="n">point</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">aoi_angles</span>

    <span class="k">def</span> <span class="nf">_calculate_vf_aoi_wedge_level</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">low_angles</span><span class="p">,</span> <span class="n">high_angles</span><span class="p">,</span>
                                      <span class="n">is_back</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate faoi modified view factors for a wedge defined by</span>
<span class="sd">        low and high angles.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        low_angles : np.ndarray</span>
<span class="sd">            Low AOI angles (between 0 and 180 deg), length = n_timestamps</span>
<span class="sd">        high_angles : np.ndarray</span>
<span class="sd">            High AOI angles (between 0 and 180 deg), length = n_timestamps.</span>
<span class="sd">            Should be bigger than ``low_angles``</span>
<span class="sd">        is_back : bool</span>
<span class="sd">            Flag specifying whether pv row surface is on back or front side</span>
<span class="sd">            of PV row (Default = True)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            faoi modified view factors for wedge</span>
<span class="sd">            shape = (n_timestamps, )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate integrand: all d_vf_aoi values</span>
        <span class="n">faoi_integrand</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_vfaoi_integrand</span><span class="p">(</span>
            <span class="n">low_angles</span><span class="p">,</span> <span class="n">high_angles</span><span class="p">,</span> <span class="n">is_back</span><span class="o">=</span><span class="n">is_back</span><span class="p">)</span>
        <span class="c1"># Total vf_aoi will be sum of all smaller d_vf_aoi values</span>
        <span class="n">total_vf_aoi</span> <span class="o">=</span> <span class="n">faoi_integrand</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Make sure vf is counted as zero if the wedge is super small</span>
        <span class="n">total_vf_aoi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">high_angles</span> <span class="o">-</span> <span class="n">low_angles</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">DISTANCE_TOLERANCE</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span>
            <span class="n">total_vf_aoi</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">total_vf_aoi</span>

    <span class="k">def</span> <span class="nf">_calculate_vfaoi_integrand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">low_angles</span><span class="p">,</span> <span class="n">high_angles</span><span class="p">,</span>
                                   <span class="n">is_back</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the timeseries view factors with aoi loss integrand</span>
<span class="sd">        given the low and high angles that define the surface.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        low_angles : np.ndarray</span>
<span class="sd">            Low AOI angles (between 0 and 180 deg), length = n_timestamps</span>
<span class="sd">        high_angles : np.ndarray</span>
<span class="sd">            High AOI angles (between 0 and 180 deg), length = n_timestamps.</span>
<span class="sd">            Should be bigger than ``low_angles``</span>
<span class="sd">        is_back : bool</span>
<span class="sd">            Flag specifying whether pv row surface is on back or front side</span>
<span class="sd">            of PV row (Default = True)</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            vf_aoi integrand values for all timestamps</span>
<span class="sd">            shape = (n_timestamps, n_integral_sections)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Turn into dimension: [n_timestamps, n_integral_sections]</span>
        <span class="n">low_angles_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">low_angles</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_integral_sections</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">high_angles_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">high_angles</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_integral_sections</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Filter out integrand values outside of range</span>
        <span class="n">include_integral_section</span> <span class="o">=</span> <span class="p">((</span><span class="n">low_angles_mat</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aoi_angles_high</span><span class="p">)</span> <span class="o">&amp;</span>
                                    <span class="p">(</span><span class="n">high_angles_mat</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">aoi_angles_low</span><span class="p">))</span>
        <span class="c1"># The integrand values are different for front and back sides</span>
        <span class="k">if</span> <span class="n">is_back</span><span class="p">:</span>
            <span class="n">faoi_integrand</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">include_integral_section</span><span class="p">,</span>
                                      <span class="bp">self</span><span class="o">.</span><span class="n">integrand_back</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">faoi_integrand</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">include_integral_section</span><span class="p">,</span>
                                      <span class="bp">self</span><span class="o">.</span><span class="n">integrand_front</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">faoi_integrand</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_calculate_aoi_angles</span><span class="p">(</span><span class="n">u_vector</span><span class="p">,</span> <span class="n">centroid</span><span class="p">,</span> <span class="n">point</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate AOI angles from direction vector of surface,</span>
<span class="sd">        centroid point of that surface, and point from another surface</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        u_vector : np.ndarray</span>
<span class="sd">            Direction vector of the surface for which to calculate AOI angles</span>
<span class="sd">        centroid : :py:class:`~pvfactors.geometry.timeseries.TsPointCoords`</span>
<span class="sd">            Centroid point of surface for which to calculate AOI angles</span>
<span class="sd">        point : :py:class:`~pvfactors.geometry.timeseries.TsPointCoords`</span>
<span class="sd">            Point of remote surface that will determine AOI angle</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            AOI angles formed by remote point and centroid on surface,</span>
<span class="sd">            measured against surface direction vector [degrees]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">v_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">point</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">centroid</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">point</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">centroid</span><span class="o">.</span><span class="n">y</span><span class="p">])</span>
        <span class="n">dot_product</span> <span class="o">=</span> <span class="n">u_vector</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">v_vector</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> \
            <span class="o">+</span> <span class="n">u_vector</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">v_vector</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">u_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">u_vector</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">v_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v_vector</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">cos_theta</span> <span class="o">=</span> <span class="n">dot_product</span> <span class="o">/</span> <span class="p">(</span><span class="n">u_norm</span> <span class="o">*</span> <span class="n">v_norm</span><span class="p">)</span>
        <span class="c1"># because of round off errors, cos_theta can be slightly &gt; 1,</span>
        <span class="c1"># or slightly &lt; -1, so clip it</span>
        <span class="n">cos_theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">cos_theta</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span>
        <span class="n">aoi_angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">cos_theta</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">aoi_angles</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_vf</span><span class="p">(</span><span class="n">aoi_1</span><span class="p">,</span> <span class="n">aoi_2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate view factor from infinitesimal surface to infinite band.</span>

<span class="sd">        See illustration: http://www.thermalradiation.net/sectionb/B-71.html</span>
<span class="sd">        Here we&#39;re using angles measured from the horizontal</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        aoi_1 : np.ndarray</span>
<span class="sd">            Lower angles defining the infinite band</span>
<span class="sd">        aoi_2 : np.ndarray</span>
<span class="sd">            Higher angles defining the infinite band</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            View factors from infinitesimal surface to infinite strip</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cosd</span><span class="p">(</span><span class="n">aoi_1</span><span class="p">)</span> <span class="o">-</span> <span class="n">cosd</span><span class="p">(</span><span class="n">aoi_2</span><span class="p">))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_angle_with_x_axis</span><span class="p">(</span><span class="n">pt_1</span><span class="p">,</span> <span class="n">pt_2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Angle with x-axis of vector going from pt_1 to pt_2</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pt_1 : :py:class:`~pvfactors.geometry.timeseries.TsPointCoords`</span>
<span class="sd">            Timeseries point coordinates of point 1</span>
<span class="sd">        pt_2 : :py:class:`~pvfactors.geometry.timeseries.TsPointCoords`</span>
<span class="sd">            Timeseries point coordinates of point 2</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            Angle between vector pt_1-&gt;pt_2 and x-axis</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">pt_2</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">pt_1</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">pt_2</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">pt_1</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rho_from_faoi_fn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is_back</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate global average reflectivity from faoi function</span>
<span class="sd">        for either side of the PV row (requires calculating view factors)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        is_back : bool</span>
<span class="sd">            Flag specifying whether to use front or back faoi function</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rho_average : float</span>
<span class="sd">            Global average reflectivity value of surface</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Will use x values at the middle of the integral sections</span>
        <span class="n">aoi_angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">180.</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_integral_sections</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Assumes that at least 2 aoi angle values, otherwise what&#39;s the point</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interval</span> <span class="o">=</span> <span class="n">aoi_angles</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">aoi_angles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Get integral intervals&#39; low, high, and middle points</span>
        <span class="n">aoi_angles_low</span> <span class="o">=</span> <span class="n">aoi_angles</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">aoi_angles_high</span> <span class="o">=</span> <span class="n">aoi_angles_low</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">interval</span>
        <span class="n">aoi_angles_middle</span> <span class="o">=</span> <span class="n">aoi_angles_low</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">interval</span> <span class="o">/</span> <span class="mf">2.</span>
        <span class="c1"># Calculate faoi values using middle points of integral intervals</span>
        <span class="k">if</span> <span class="n">is_back</span><span class="p">:</span>
            <span class="n">faoi_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">faoi_fn_back</span><span class="p">(</span><span class="n">aoi_angles_middle</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">faoi_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">faoi_fn_front</span><span class="p">(</span><span class="n">aoi_angles_middle</span><span class="p">)</span>
        <span class="c1"># Calculate small view factor values for each section</span>
        <span class="n">vf_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vf</span><span class="p">(</span><span class="n">aoi_angles_low</span><span class="p">,</span> <span class="n">aoi_angles_high</span><span class="p">)</span>
        <span class="c1"># Multiply to get integrand</span>
        <span class="n">integrand_values</span> <span class="o">=</span> <span class="n">faoi_values</span> <span class="o">*</span> <span class="n">vf_values</span>
        <span class="k">return</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">integrand_values</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span></div>


<span class="k">def</span> <span class="nf">faoi_fn_from_pvlib_sandia</span><span class="p">(</span><span class="n">pvmodule_name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate a faoi function from a pvlib sandia PV module name</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pvmodule_name : str</span>
<span class="sd">        Name of PV module in pvlib Sandia module database</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    faoi_function</span>
<span class="sd">        Function that returns positive loss values for numeric inputs</span>
<span class="sd">        between 0 and 180 degrees.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get Sandia module database from pvlib</span>
    <span class="n">sandia_modules</span> <span class="o">=</span> <span class="n">pvlib</span><span class="o">.</span><span class="n">pvsystem</span><span class="o">.</span><span class="n">retrieve_sam</span><span class="p">(</span><span class="s1">&#39;SandiaMod&#39;</span><span class="p">)</span>
    <span class="c1"># Grab pv module sandia coeffs from database</span>
    <span class="n">pvmodule</span> <span class="o">=</span> <span class="n">sandia_modules</span><span class="p">[</span><span class="n">pvmodule_name</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">fn</span><span class="p">(</span><span class="n">angles</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;fAOI loss funtion: calculate how much light is absorbed at given</span>
<span class="sd">        incidence angles</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        angles : np.ndarray or list</span>
<span class="sd">            Angles measured from surface horizontal, from 0 de 180 deg</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            fAOI values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="n">angles</span>
        <span class="c1"># Transform the inputs for the SAPM function</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">angles</span> <span class="o">&gt;=</span> <span class="mi">90</span><span class="p">,</span> <span class="n">angles</span> <span class="o">-</span> <span class="mi">90</span><span class="p">,</span> <span class="mf">90.</span> <span class="o">-</span> <span class="n">angles</span><span class="p">)</span>
        <span class="c1"># Use pvlib sapm aoi loss method</span>
        <span class="k">return</span> <span class="n">pvlib</span><span class="o">.</span><span class="n">pvsystem</span><span class="o">.</span><span class="n">sapm_aoi_loss</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">pvmodule</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">fn</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, SunPower Corporation

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>